/**
 * Common Database File
 * 
 * This file should be the same between all services that utilize the colisee-db
 */

import * as Knex from "knex";
import * as _ from "lodash";

import * as vars from "../vars";

// Node Environment
const NODE_ENV: string = _.defaultTo<string>(process.env.NODE_ENV, "development");
const IS_DEVELOPMENT: boolean = NODE_ENV === "development";
const IS_PRODUCTION: boolean = NODE_ENV === "production";

// Table Constants
export const TEAMS_TABLE = "teams";
export const SUBMISSIONS_TABLE = "submissions";
export const GAMES_TABLE = "games";
export const GAME_SUBMISSIONS_TABLE = "games_submission"

// Statuses lists
export const TEAM_SUBMISSIONS_STATUSES = [ "queued", "building", "finished", "failed" ];
export const GAME_STATUSES = [ "queued", "playing", "finished" ];

// Main KNEX connection
export const connection = (NODE_ENV === "development" ? buildDevelopmentConnection() : buildProductionConnection());

function buildDevelopmentConnection(): Knex {
    return Knex({
        client: "sqlite3",
        connection: {
            filename: "./db.sqlite",
        }
    });
}

function buildProductionConnection(): Knex {
    return Knex({
        client: "postgresql",
        connection: {
            host: vars.DB_HOST,
            port: vars.DB_PORT,
            user: vars.DB_USER,
            password: vars.DB_PASS,
            database: vars.DB_NAME
        }
    });
}
export async function initializeDatabase(force: boolean = false): Promise<void> {
    if(IS_PRODUCTION) throw new Error("Cannot initialize database on production unless force=true.");

    // Drop All Tables
    const dropAll = [
        TEAMS_TABLE,
        SUBMISSIONS_TABLE,
        GAMES_TABLE,
        GAME_SUBMISSIONS_TABLE
    ].map(table => connection.schema.dropTableIfExists(table));
    await Promise.all(dropAll);

    // Create All Tables
    await connection.schema.createTable(TEAMS_TABLE, table => {
        table.increments("id");
        table.string("name", 64)
            .notNullable()
            .unique();

        table.string("contact_email", 64)
            .notNullable()
            .unique();
        table.string("password", 256)
            .notNullable();
        table.boolean("is_eligible")
            .notNullable();

        table.timestamps(true, true);
    });

    await connection.schema.createTable(SUBMISSIONS_TABLE, table => {
        table.increments("id");
        table.integer("team_id")
            .unsigned()
            .references(`${TEAMS_TABLE}.id`);
            
        table.integer("version").notNullable();
        table.enu("status", TEAM_SUBMISSIONS_STATUSES).notNullable();

        table.string("submission_url");
        table.string("log_url");
        table.string("image_name")
            .comment("The docker image of the submission contained on the Arena Docker Registry");

        table.timestamps(true, true);

        // Constraints
        table.unique(["team_id", "version"]);
    });

    await connection.schema.createTable(GAMES_TABLE, table => {
        table.increments("id");
        table.enu("status", GAME_STATUSES);

        table.string("win_reason");
        table.string("lose_reason");
        table.integer("winner_id")
            .unsigned()
            .references(`${SUBMISSIONS_TABLE}.id`)
            .comment("The id of the winning submission");

        table.string("log_url")
            .comment("Link to the game log.");

        table.timestamps(true, true);
    });

    await connection.schema.createTable(GAME_SUBMISSIONS_TABLE, table => {
        table.increments("id");

        table.integer("submission_id")
            .unsigned()
            .notNullable()
            .references(`${SUBMISSIONS_TABLE}.id`)
            .comment("The submission that is a player in the linked game.");

        table.integer("game_id")
            .unsigned()
            .notNullable()
            .references(`${GAMES_TABLE}.id`)
            .comment("The game that is/was played by the linked player.");

        table.string("output_url")
            .comment("Link to the output generated by the linked submission.");

        table.timestamps(true, true);
    })
}

